#include <iostream>
using namespace std;

int main() {
	

	/* 포인터와 배열은 어면히 다르지만 이에대한 혼동이 있을 수 있으니 정리해보자
	*
	* 포인터 -> 주소를 담는 바구니의 개념*/ 
	int* p;
	
	/*진짜 데이터는 저~ 멀리 어딘가(메모리)에 존재하고 있다.
	* 포인터로 선언한 포인터 변수는 '어딘가(메모리)에 존재하는 진짜 데이터'로 이동하는 포탈과 같은 개념이다. */

	/* 배열 -> 닭장처럼 데이터의 묶음 형태라고 보면된다. (선언하는 것에 따라 용량이 달라질 수 있다.)
	* 포인터와 달리 진짜 데이터가 바로 Array[0] 부터 존재하기에 포탈을 타는 개념은 없다. */
	int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8 };

	/* 위에서 설명한 것만으로도 차이가 존재하지만 많은 사람들이 [배열 = 포인터] 라고 착각하는 경향이 있다.
	* 그 이유는 => [배열의 이름]은 배열의 시작 주소값을 가리키는 TYPE* 포인터로 변환이 가능하기 때문이다. */

	/* - [TYPE형 1차원 배열]과 [TYPE*형 포인터]는 완전히 문법적으로 호환이 된다. 
	이 말은 곧 배열과 포인터를 따로 선언했음에도 불구하고 이를 문법적으로 같게 보일 수 있다는 이야기다.
	*/

	p = arr; // 이렇게 같은 데이터를 구성했다고 하자.
	
	cout << p[0] << endl;
	cout << arr[0] << endl;
	cout << p[5] << endl;
	cout << arr[0] << endl;
	
	cout << *p << endl; // p[0]
	cout << *arr << endl; // arr[0]
	cout << *(p+3) << endl; 
	cout << *(arr+3) << endl;

	// 이제 지옥을 맛보자 (2차원 배열 vs 다중 포인터) 

	// [1][2][3][4]
	int arr2[2][2] = { {1, 2}, {3, 4} };
	
	// int** pp = arr2; // 이렇게는 변환이 되지 않는다. 

	// 우선 캐스팅해서 진행한다.
	// pp[ 주소 ] => 주소1[ 주소2 ] => 주소2[  ] << 4바이트
	int** pp = (int**)arr2;

	// 값을 꺼내기 위해서는 ? (**pp) 를 실행해보자 !
	cout << (**pp) << endl; // 그런데 ?!
	/* 예외 발생(0x005C1B33, 11.포인터 마무리.exe): 0xC0000005: 0x00000001 위치를 읽는 동안 액세스 위반이 발생했습니다.. */

	/* 이러한 에러(크래시)가 나는 이유가 무엇인가?!
	
	사실상 이 부분이 가장 중요하다. 1차 배열과 일반 포인터를 다룰 때는 이러한 에러가 나지 않는다.

	이유는 **pp가 주소1[  ] 안으로 1차적으로 접근할 때, 주소1[  ] 안에 있는 데이터가 유효하지 않는 값이기에 발생하는 것이다.

	1차원 배열과 일반 포인터의 값을 놓고 보면 *p를 타고 들어갔을 때, 주소1 [ 배열의 인덱스 ] 로 존재한다.
	그렇기에 *p는 이를 타고 들어가서 값을 접근 할 수 있다. 즉, 주소1[  ]가 유효했던 값을 가지고 있었기에 가능했던 것이다.

	하지만 2차원 배열과 다중 포인터는 이에 부합할 수 없다.

	2차원 배열 = 다중 포인터를 캐스팅으로 선언해서 사용한다고 하더라도

	**pp 가 주소1 [ 주소2 ]로 이동을 할 때, 주소2에 해당하는 값은 배열의 값이 들어가 있기에 크래시가 날 수 밖에 없다.
	(즉, 주소2 에는 유효한 주소값으로 들어가 있지 않는다는 것이다.)

	그렇기에 이는 억지로 캐스팅하여 선언해서 사용한 n차원 포인터와 다중 포인터의 문제로 드러날 수 밖에 없는 경우이다.
	*/
	
	// 이를 사용하기 위해서는 어떻게 해야하는가?
	int(*p2)[2] = arr2; // <- 두 개의 int형을 가지고 있는 포인터를 나타나는 것이다.
	// 이를 해석하자면 [ 주소 ] -> [ 1 ][ 2 ]

	cout << (*p2)[0] << endl;
	cout << (*p2)[1] << endl; // 이를 확인해보면 이전(**pp)에는 할 수 없던 것을 진행 할 수 있다.
	
	// 그럼 [3][4] 는 어떻게 접근하는가? -> 쉽게 생각하면 포인터에 연산을 진행하면 된다.
	cout << (*p2 + 1)[0] << endl;
	cout << (*p2 + 1)[1] << endl; // 이렇게 *p2 + 1 진행을 통해 다음 배열의 자리로 이동하게 되어 조회할 수 있다.

	return 0;
}
