#include <iostream>
using namespace std;

/* 맴버 변수를 어떻게 초기화 하는가(다양한 문법이 존재한다.)
초기화를 왜 해야하는 건가?
 - 버그 예방에 중요
 - 포인터 등 주소값이 연루되어 있을 경우 */

/* 이전의 상속개념에서는 상위 클래스의 생성자를 통해 기본적인 생성자를 만들고 추가적으로 하위 클래스의 맴버 변수를 만들었다.
이를 진행하면서 Knight() : Player(1), _hp(200) {} 와 같은 문법을 통해 상위 클래스의 기본 생성자가 아닌 기타 생성자를 접근했다.
이는 어디까지나 상속관계를 설명하는 문법이다.

그렇다면 포함관계가 등장하게 된다면 어떨까?

기본적으로 상속관계와 포함관계는 어면히 다른 개념이다.

상속관계와 포함관계를 구분하는 방법!!
(Is-A) / (Has-A) 를 통해 구분할 수 있다.

1. Knight is a Player => true -> 상속관계
(2. Knight has a Player => false)

3. Knight has an Inventory => true -> 포함관계
(4. Knight is an Inbentory => false)

다음과 같이 Player를 상속받은 클래스가 공통으로 가지고 있어야할 Inventory class를 생성했다.*/
class Inventory {
public:
    Inventory() { cout << "Inventory()" << endl; }
    Inventory(int size) { cout << "Inventory(int size)" << endl; _size = size; }

    ~Inventory() { cout << "~Inventory()" << endl; }

public:
    int _size = 10; // C++ 11문법을 사용해서 초기화를 해봤다.
};

class Player {
public:
    Player() { }
    Player(int _hp) { }
 };

class Knight : public Player {
public:

    /* 포함관계도 상속관계와 마찬가지고 기타생성자를 사용하게 된다면 동일한 문법을 통해 진행되어야한다.
    (그렇지 않는다면 기본생성자를 생성 후, 소멸시키고 기타생성자를 생성하는 바보같은 일을 컴파일러가 저지르기 때문이다.) */

    /* 참조타입, 상수타입의 경우, 선처리 영역에서 그 값을 설정해주어야 하며 이는 생성자 로직 안에 생성해서는 안된다. */ 
    Knight() : Player(1), _hp(200), _Inventory(20), _hpRef(_hp), _hpConst(200)

        /* 초기화 방법 세 번째 = 초기화 리스트 [선처리 영역에서 이루어지는 초기화]
        Player() {}
        Inventory() {} */

        /* 초기화 리스트가 필요한 경우
        - 상속관계에서 원하는 부모 생성자를 호출할 때 필요
        - 정의함과 동시에 초기화가 필요한 경우 (참조 타입, const 타입) */
    {
        /* 초기화 방법 첫 번째 = 생성자 내에서 진행 */
        _hp = 100;
    }
public:
    int _hp; // 초기화를 하지 않는다면 컴파일러가 임의로 정한 값이 들어가 있다.
    // int _hp = 100; // 초기화 방법 두 번째 = C++ 11 문법에서 사용하는 방법이다. 
    // 이는 팀의 특색에 따라 맞춰서 사용해야 할 수도 있다.

    /* Inventory를 포함해야하는 Knight 클래스는 어디에 Inventory를 초기화 해주어야 하는가. 
    
    우선 Inventory를 맴버 변수에 작성해준다.

    이 상태에서 빌드 이후 실행하게 된다면 두 가지의 경우로 나뉠 수 있다.
    1. Inventory() 기본생성자를 Knight() 기본생성자 선처리 영역에서 생성한다.
    2. Inventory(int size) 기타생성자를 실행할 경우,
        우선적으로 Inventory() 기본생성자를 생성 후, Inventory(int size) 기타생성자가 생성된다.
        왜 이렇게 진행되는가? => Knight() 선처리 영역에서 Inventory() 기본생성자를 생성하기 때문이다.
        
        기본생성자가 선처리 영역에서 생성된 이후, 기타생성자가 생성되려 할 때 기본생성자를 소멸시키고 
        기타생성자를 이어서 생성하는 과정을 거치게 된다.

        [포함관계에서 기본생성자와 기타생성자가 같이 사용될 때의 과정]
        Inventory() 기본생성자 -> Inventory(int size) 기타생성자 
            -> ~Inventory() 소멸자[기본생성자] -> ~Inventory() 소멸자[기타생성자]

    그렇기 때문에 포함관계의 기타생성자를 사용하기 위해서는 상속관계의 기타생성자를 사용하는 것처럼 문법을 작성해주어야 한다.
    */
    Inventory _Inventory;

    /* 정의함과 동시에 초기화가 필요한 경우 (참조 타입, const 타입) 
    _hpRef 의 경우, 포인터와 달리 null 상태로 존재할 수 없는 요소이기에 이는 초기값이 무조건 존재해야한다.
    _hpConst 의 경우, 초기값을 설정하지 않을 수가 없는 요소이기에 이는 초기에 작성해야 한다.
    (생성된 이후 변할 수가 없는 요소들이다.) */
    int& _hpRef;
    const int _hpConst; 
    /* 그럼 이 요소들은 어디서 작성해주어야 하는가?
    생성자 내부에 작성하는게 아니라 선처리 영역에 작성해야 한다. */
};

int main() {
    Knight k;

    /* 클래스 맴버 변수를 초기화 하지 않고 빌드를 진행할 경우 컴파일러는 보통 에러를 출력한다.
    이는 컴파일러의 설정을 변경함에 따라서 에러를 출력하지 않게 하도록 할 수 있다.

    하지만 Knight() {} 만 작성해서 진행할 경우 에러가 출력되지 않는다.
    그럼 빌드 후, Knight k의 _hp를 살펴보자. */
    cout << k._hp << endl;

    /* k._hp를 출력하면 무슨 값이 출력될까? (기본값이 정해져 있지 않으니 0이 출력되지 않을까?)

    그렇지 않다.... Knight k 객체의 메모리 주소에 담긴 _hp의 주소값을 출력하고 있다.
    그렇다면 왜 이런 현상이 나타나는 것인가?

    객체를 생성할 때, k는 스택 메모리 영역에 생성이 되는데 
    본래 이 영역에는 컴파일러가 '명확하게 들어간 값을 제외하고 나머지 값을 이상한 값으로 채워놓는다'
    그렇기에 이 영역에는 이상한 값들이 존재하는데 

    k는 초기화를 하지 않은 상태에서 스택 메모리 영역을 할당 받았기에 이 값이 그대로 출력이 되는 원리이다.

    즉, 초기화를 하지 않는다면 객체는 컴파일러가 만든 이상한 값을 가지고 있는 셈이라는 것이다.
    */

    return 0;
}