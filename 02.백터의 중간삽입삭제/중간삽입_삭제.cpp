#include <iostream>
#include <vector>
using namespace std;

int main() {

	// Container : 데이터를 저장하는 객채 ( 자료구조 Data Structure )

	// 반복자(Iterator) : 포인터와 유사한 개념. 컨테이너의 원소(데이터)를 가리키고, 다음/이전 원소로 이동 가능
	vector<int> v(10);

	for (vector<int>::size_type i = 0; i < v.size(); i++) {
		v[i] = i;
	}

	/* iterator == ? pointer 와 비슷한 개념이라고 위에서 설명했다. 그럼 어떻게 다른지에 대해 알아보자. */
	vector<int>::iterator it;
	int* ptr;

	it = v.begin(); // vector의 첫번째 값을 가리키는 기능
	ptr = &v[0];

	cout << (*it) << endl;
	cout << (*ptr) << endl;

	/* 이를 실행하여 메모리를 조사해보면 둘다 같은 값을 가리키고 있다는 것을 알수 있다.
	하지만 it 같은 경우는 ptr과는 다르게 다른 값들을 더 들고 있는 모습을 볼 수 있는데
	이는 어떤 컨테이너에 소속되어 있는지를 알려주는 여러값임을 알 수 있다. (어디에 소속된 포인터 같은 개념) 
	
	반면에 문법은 포인터와 다를바 없다. Iterator를 타고 들어가면 문법 안의 ptr에서 pointer to element in vector가 작성되어 있다. */

	// 다음/이전 데이터 이동
	it++;
	--it;

	// begin 은 처음 값을 가리키는 상태를 의미한다.
	vector<int>::iterator itBegin = v.begin();

	// end 는 마지막 값을 가리키는대 이는 v의 마지막 값이 아닌
	// 마지막 값의 ++가 된 상태임을 알고 있어야 한다. 
	// 무턱대고 v.end()를 통해서 마지막 값을 알려고 하면 이는 유효하지 않은 값을 들고있다는 것을 명심해야 한다.
	// 이는 정말로 vector의 마지막 값을 알기 위해서 사용하는 것이다.
	vector<int>::iterator itEnd = v.end();

	// 거의 이를 문법화 해서 사용하게 될 것이다.
	// 하지만 다른 컨테이너는 v[i]와 같은 인덱스 접근이 안될 수 있다.
	// iterator는 vecrot뿐 아니라, 다른 컨테이너에도 공통적으로 있는 개념이기에
	for (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {
		cout << (*it) << endl;
	}

	// const int*
	vector<int>::const_iterator cit1 = v.cbegin();
	// *cit1 = 100;

	// 반대로 시작점을 잡는 방법 -> 거의 사용된 적은 없으나 알아두면 나쁠건 없다.
	for (vector<int>::reverse_iterator it = v.rbegin(); it != v.rend(); ++it) {
		cout << (*it) << endl;
	}

	// - 중간 삽입/삭제
	// - 처음/끝 삽입/삭제
	// - 임의 접금
	/* vector = 동적배열 = 동적으로 커지는 배열 => 어쨌든 배열이라는 것이다.
	그렇기에 원소가 하나의 메모리 블록에 연속되어 저장된다는 것인다. */

	/* vector의 중간 삽입/삭제는 매우 비효율적이다!
	[                              ]
	[0] [1] [2] [3] [4] [5] <= 중간에 데이터를 삽입하고 싶다면?
	
	[2] [3] [4] 를 밀어내고 [5]를 넣어주는 과정이 필요하다. (배운대로 한다면 말이다.)
	위의 과정은 데이터를 밀어내고 밀어낸 빈 공간에 데이터를 집어넣는 방식으로 진행된다.
	즉, 한 개 이상의 과정(복사)을 꼭 거치는 방법을 필연적으로 사용하게 된다는 것이다.

	만약, 천만 개의 데이터를 복사한다고 하면 매우 골치아파지게 된다.

	[                              ]
	[0] [1] [2] [3] [4] [5] <= 중간에 데이터를 삭제하고 싶다면?

	간단하게 삭제를 하는 개념이라면 배열의 규칙을 위반할 수 있다.
	배열은 하나의 매모리 블록에 연속되어 존재햐야 한다는 규칙을 가지고 있기에 
	만약 중간의 값을 nullptr로 지정을 해버린다면 Error는 필연적으로 발생할 것이고
	애초에 컴파일러가 허락하지 않는다.

	그렇기에 중간의 데이터를 삭제하게 된다면 삭제한 부분 뒷 부분의 데이터를 
	앞으로 밀어주는 과정(복사)가 이루어지게 되어 프로그램에 부하를 야기할 수 있다.

	일반적으로 vector 같은 경우는 '중간 삽입/삭제'가 매우 비효율적 이다. */

	/* vector의 처음/끝 삽입/삭제는 비효율/효율이다.
	
	[                              ]
	[0] [1] [2] [3] [4] [5] <= 처음에 데이터를 삽입/삭제하고 싶다면?
	중간 삽입/삭제에서 알아본 개념들과 일맥상통한 개념이 작동하기에 = 비효율적이다.

	[                              ]
	[0] [1] [2] [3] [4] [5] <= 끝에 데이터를 삽입/삭제하고 싶다면?
	정말 다행인게, 끝에서 데이터를 삽입/삭제하는 기능은 효율적으로 작동한다.
	기존의 값(들)을 복사하는 과정을 거치지 않고 진행되는 방식이다.

	유일하게 배열의 규칙을 위반하지 않으면서 데이터를 보존하는 방식으로 작동하는 개념이다.

	이에 대한 대표적인 함수로써 push_back(), pop_back() 이 존재한다. */

	/* vector의 임의 접근은 무엇인가?
	배열안에서 어느 지점에 있는 값에 접근할때 보통 arr[i]와 같은 방식으로 진행하는데

	이 방법이 바로 임의접근 Random Access 의 개념이다.

	이는 배열이 하나의 메모리 블록안에 온전히 존재하기에 가능한 것이다.

	즉, 배열이 온전하다면 임의접근은 필연적으로 동작하게 된다는 것이다. */

	return 0;
}