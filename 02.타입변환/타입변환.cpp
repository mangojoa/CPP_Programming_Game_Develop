#include <iostream>
using namespace std;

/* 타입변환
malloc -> void*을 반환하고, 이를 우리가 (타입변환)을 통해 사용했었다. */

class Knight {
public:
	int _hp = 10;
};

class Dog {
public: 
	Dog() {

	}
	// 타입 변환 생성자
	Dog(const Knight& knight) {
		_age = knight._hp;
	}
	// 타입 변환 연산자
	auto operator Knigth()
	{
		return (Knight)(*this);
	}
public:
	int _age = 1;
	int _cuteness = 2;
};

class BullDog : public Dog {
public:
	bool _french; // 프렌치 불독인지에 대한 여부 판별
};

int main() {

	/*  ---------- 타입변환 유형 (비트열 재구성 여부) ----------
	[1] 값 타입 변환
	의미를 유지하기 위해서, 원본 객체와 다른 비트열 재구성 
	비트열 재구성 => 값을 저장하는 비트단위가 다르게 재구성 되었다라는 의미
	*/
	{
		int a = 12345678; // 2의 보수
		float b = (float)a; // 부동소수점(지수+유효숫자)
		cout << b << endl;

		// 이를 출력해서 살펴보면 a에 담긴 값과 b에 담긴 값이 각각 다른형태로 저장되어있음을 확인할 수 있다.
	}

	/* [2] 참조 타입 변환
	특정 비트열을 재구성하지 않고, '관점'만 바꾸는 것 
	현업에서는 거의 쓸일은 없지만 포인터 타입 변환도 '참조 타입 변환'과 동일한 룰을 따르니까 일석이조로 배워두자!

	*/
	{
		int a = 12345678; // 2의 보수
		float b = (float&)a; // 부동소수점(지수+유효숫자)
		cout << b << endl;

		// 이를 출력해서 살펴보면 a에 담긴 값이 b에 그대로 담겨있다. (a에서 사용한 '2의 보수'개념을 그대로 float에 넣은 셈)
	}
	
	/*  ---------- 안전도 분류 ----------
	[1] 안전한 변환
	의미가 항상 100% 완전히 일치하는 경우
	같은 타입이면서 크기만 더 큰 바구니로 이동
	작은 바구니 -> 큰 바구니로 이동 OK (업케스팅)
	ex) char -> short, short -> int, int -> __int64 */
	{
		int a = 123456789;
		__int64 b = a;
		cout << b << endl;
	}

	/* [2] 불안전한 변환 
	의미가 항상 100% 일치한다고 보장하지 못하는 경우
	타입이 다르거나 같은 타입이지만 큰 바구니 -> 작은 바구니 이동 (다운캐스팅) 
	다운 캐스팅이 이루어진다면 데이터의 손실이 일어날 가능성이 매우 높다 */
	{
		int a = 123456789;
		float b = a;
		short c = b;
		cout << b << endl;
		cout << c << endl;
	}

	/*  ---------- 프로그래머 의도에 따라 분류 ----------
	[1] 암시적 변환
	이미 알려진 타입 변환 규칙에 따라서 컴파일러가 '자동'으로 타입 변환 */
	{
		int a = 123456789;
		float b = a; // 암시적으로 컴파일러가 자동으로 int -> float으로 변환한다.
		cout << b << endl;
	}

	/* [2] 명시적 변환 */
	{
		int a = 123456789;
		int* b = (int*)a; // 이를 명시적으로 선언하지 않는다면 컴파일러는 매우 위험한 상황이라고 판단하여 에러를 낸다.
		cout << b << endl;
	}

	/*  ---------- 아무런 연관 관계가 없는 클래스 사이의 변환 ----------
	[1] 연관없는 클래스 사이의 '값 타입' 변환
	일반적으로 이는 이루어질 수가 없다. 하지만 예외적으로 타입변환 생성자/연산자 를 사용하게 된다면 가능하다. */
	{
		Knight knight;
		Dog dog = (Dog)knight;
		Knight knight2 = dog;
	}

	/* [2] 연관없는 클래스 사이의 참조 타입 변환 
	참조타입 값으로 통과는 된다는 것이 특징이다. 어셈블리 언어적으로 본다면 이는 문법적으로 문제가 없기 때문이다. */
	{
		Knight knight;
		Dog& dog = (Dog&)knight;
		dog._cuteness = 12;
	}
	
	/*  ---------- 상속 관계에 있는 클래스 사이의 변환 ----------
	[1] 상속 관계 클래스의 '값 타입' 변환 
	상위 클래스에서 하위 클래스로 진행하는 값 타입 변환은 불가능하다.(애초에 안되는 것이다.)

	하지만 하위 클래스에서 상위 클래스로 진행하는 값 타입 변환은 가능하다.
	단, 타입 변환 생성자/연산자가 선언되어 있다면 불가능 하기에 만일을 대비해서 기본 생성자를 꼭 생성해두자. */
	{
		// Dog dog;
		// BullDog bulldog = dog;

		BullDog  bulldog;
		Dog dog = bulldog;
	}

	/* [2] 상속 관계 클래스의 참조 타입 변환
	상위 클래스에서 하위 클래스로 진행하는 값 타입 변환은 불가능하다. (암시적으로 안된다는 것이다.)
	하지만 명시적으로 변환을 하게 된다면 가능한 일이다.

	하위 클래스에서 상위 클래스로 진행하는 값 타입 변환은 가능하다. */
	{
		// Dog dog;
		// BullDog& bulldog = (BullDog&)dog;

		BullDog  bulldog;
		Dog& dog = bulldog;
	}

	/* 결론
	* [값 타입 변환] : 진짜 비트열도 바꾸고 ~ 논리적으로 말이 되게 바꾸는 변환
	* 논리적으로 말이 된가? 
	* 논리적으로 말이 안된다?
	* [참조 타입 변환] :" 비트열을 냅두고 우리의 '관점'만 바꾸는 변환
	* 땡깡을 부리면(명시적 요구) 해주긴 하는데, 말 안해도 '그냥' (암시적)으로 해주는지는 안전성 여부와 연관이 있음
	* 안전하다?
	* 위험하다?
	* 메모리 침범 위험이 있는 경우 '그냥' (암시적으로) 해주진 않는다.(위험하기에)
	* 명시적으로 정말정말 하겠다고 최종 서명을 하면 된다.
	*/

	return 0;
}
