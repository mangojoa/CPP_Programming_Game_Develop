#include <iostream>
using namespace std;

/* 타입변환
malloc -> void*을 반환하고, 이를 우리가 (타입변환)을 통해 사용했었다. */

class Knight {
public:
	int _hp = 10;
};

class Dog {
public: 
	Dog(const Knight& knight) {
		_age = knight._hp;
	}
public:
	int _age = 1;
	int cuteness = 2;
};

int main() {

	/*  ---------- 타입변환 유형 (비트열 재구성 여부) ----------
	[1] 값 타입 변환
	의미를 유지하기 위해서, 원본 객체와 다른 비트열 재구성 
	비트열 재구성 => 값을 저장하는 비트단위가 다르게 재구성 되었다라는 의미
	*/
	{
		int a = 12345678; // 2의 보수
		float b = (float)a; // 부동소수점(지수+유효숫자)
		cout << b << endl;

		// 이를 출력해서 살펴보면 a에 담긴 값과 b에 담긴 값이 각각 다른형태로 저장되어있음을 확인할 수 있다.
	}

	/* [2] 참조 타입 변환
	특정 비트열을 재구성하지 않고, '관점'만 바꾸는 것 
	현업에서는 거의 쓸일은 없지만 포인터 타입 변환도 '참조 타입 변환'과 동일한 룰을 따르니까 일석이조로 배워두자!

	*/
	{
		int a = 12345678; // 2의 보수
		float b = (float&)a; // 부동소수점(지수+유효숫자)
		cout << b << endl;

		// 이를 출력해서 살펴보면 a에 담긴 값이 b에 그대로 담겨있다. (a에서 사용한 '2의 보수'개념을 그대로 float에 넣은 셈)
	}
	
	/*  ---------- 안전도 분류 ----------
	[1] 안전한 변환
	의미가 항상 100% 완전히 일치하는 경우
	같은 타입이면서 크기만 더 큰 바구니로 이동
	작은 바구니 -> 큰 바구니로 이동 OK (업케스팅)
	ex) char -> short, short -> int, int -> __int64 */
	{
		int a = 123456789;
		__int64 b = a;
		cout << b << endl;
	}

	/* [2] 불안전한 변환 
	의미가 항상 100% 일치한다고 보장하지 못하는 경우
	타입이 다르거나 같은 타입이지만 큰 바구니 -> 작은 바구니 이동 (다운캐스팅) 
	다운 캐스팅이 이루어진다면 데이터의 손실이 일어날 가능성이 매우 높다 */
	{
		int a = 123456789;
		float b = a;
		short c = b;
		cout << b << endl;
		cout << c << endl;
	}

	/*  ---------- 프로그래머 의도에 따라 분류 ----------
	[1] 암시적 변환
	이미 알려진 타입 변환 규칙에 따라서 컴파일러가 '자동'으로 타입 변환 */
	{
		int a = 123456789;
		float b = a; // 암시적으로 컴파일러가 자동으로 int -> float으로 변환한다.
		cout << b << endl;
	}

	/* [2] 명시적 변환 */
	{
		int a = 123456789;
		int* b = (int*)a; // 이를 명시적으로 선언하지 않는다면 컴파일러는 매우 위험한 상황이라고 판단하여 에러를 낸다.
		cout << b << endl;
	}

	/*  ---------- 아무런 연관 관계가 없는 클래스 사이의 변환 ----------
	[1] 연관없는 클래스 사이의 '값 타입' 변환
	일반적으로 이는 이루어질 수가 없다. 하지만 예외적으로 타입변환 생성자/연산자 를 사용하게 된다면 가능하다. */
	{
		Knight knight;
		Dog dog = (Dog)knight;
	}

	return 0;
}
