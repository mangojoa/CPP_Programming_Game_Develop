#include <iostream>
using namespace std;

/* 우선적으로 전역변수와 지역변수가 존재한다는 것은 당연히 알고 있다.

전역변수 => 작성한 파일 안 어디에서나 사용할 수 있는 변수
지역변수 => 지정한 루프 안에서 사용할 수 있는 변수 

위의 개념이라고 알고 있다.

전역변수는 기본적으로 스택 프래임 중 DATA영역(.rodata .data BBS)에 해당한다.
초기화 여부, const 등 설정을 하더라도 DATA영역에서 사용된다. */
int globalValue = 0;

void Test() {
    cout << "GlobalValue is " << globalValue << endl;
}

/* 그럼 여기서 전역변수와 지역변수를 왜 나눈 것인가?

한 가지 가정을 해보자. 
이처럼 간단한 예제를 만드는 것이 아닌 code line이 100만줄 정도 된다고 하는 프로젝트에서

간단하게 전역변수를 남발했다고 하자..... (벌서부터 어질어질하다.)

code line: 1,000,000줄 
function: 6,000개
GlobalValue: 3,000개

이렇게 있는 상황속에서 전역변수 만으로 컨트롤 하게 되면 상당한 복잡성을 갖게 된다.
A라는 전역변수를 어디에서 물고 이걸 또 다른 곳에서 물고 연쇄적인 반응들이 결국에는 애러나 크러시 형태로 나타나게 되는데 

이를 방지하기 위해서(이외에도 다양한 이유가 있다.) 지역변수라는 개념이 필요한 것이다.
*/
void IncreseHp(int hp) {
    hp = hp + 1;
}


int main() {
    
    Test();

    /* 지역변수는 해당하는 영역(함수) 안에서 사용되는 변수의 개념이다.
    이는 사용하는 법에 따라 의미가 달라진다. 지역변수가 어떻게 사용이 되는지 알아보자.

    같은 메모리 안에서 스택 영역에 해당하는 부분에 생성된다는 것을 알 수 있다.
    스택 영역의 경우, 컴파일 타임의 크기에 따라 결정된다. */

    int hp = 1;
    
    cout << "Increse 호출 전 : " << hp << endl;
    IncreseHp(hp);
    cout << "Increse 호출 후 : " << hp << endl;

    /* 지금과 같이 localValue를 IncreseHp로 보내어 연산을 한 후, 
    다시 출력을 하면 2가 나오지 않을까?! 하는 행복회로를 돌려 볼 수 있다.

    결과는 아니다. (행복회로 불타서 없어짐) 이유는 간단하다. 
    main()에서 사용하는 지역변수인 int hp가 
    void IncreseHp(int hp)의 인자값으로 들어가 
    hp = hp + 1 라는 연산을 거친다고 한다해도 main() { int hp = 1; }에는 아무런 영향을 주지 않기 때문이다.

    조금 쉽게 말한다면 반환값(return)이 없다...

    이를 통해서 알 수 있는 것 => 전역변수는 어디에나 영향받거나 줄 수도 있지만 지역변수는 그에 비해 한정적이다.
    */

}