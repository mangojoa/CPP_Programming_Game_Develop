#include <iostream>
using namespace std;

/* STL을 배우기 위해서는 함수포인터를 알고 가야하기 때문에
함수포인터를 배워보도록 하자. */

// 이렇게 선언한 함수 조차도 어셈블리 언어로 실행하는 과정을 본다면
// 이 함수의 주소로 이동하는 장면을 목격할 수 있다. 
// 즉, 함수가 실행될 때 함수의 변수명은 주소값을 담아두는(이와 같이 함수를 실행하는) 역할을 
// 한다는 것을 알 수 있게 된다. (이해를 쉽게 하자면 이렇다는 것이다.)
int Add(int a, int b) {
    return a + b;
}

class Item {
public:
    Item() : _itemId(0), _rarity(0), _ownerId(0) {

    }
public:
    int _itemId;
    int _rarity;
    int _ownerId;
};

/* 함수포인터를 사용할 수 밖에 없는 이유에 대하여

아래에는 아이템을 _itemid를 통해서 원하는 아이템을 검색하면 이를 반환해주는 함수이다.
나아가 _rarity, _ownerId와 같은 값으로도 아이템을 검색할 수 있다고 한다면 
여기서 사용되는 코드의 중복이 일어날 수 밖에 없을 것이다. (비슷한 현업에서도 그런 부분이 많다.)

그렇기에 이러한 중복적인 부분을 지속적으로 관리를 하기에는 매우 어려움이 뒤따르기 마련이고
코드를 작성하는 부분에 있어서도 많은 부분에 하나하나 넣어줘야 한다는 문제가 발생한다. 

이때문에 필연적으로 관리도 수월하고 작성하는 부분에서도 편리한 '함수 포인터'를 사용하는 것이 적합하다.

필요한 함수 하나만 작성하고 사용되는 부분에 '함수포인터'를 이용하여 작성하게 된다면
1. 작성에 용이하며 가독성이 매우 좋아진다.
2. 관리를 하는데 있어 응집력이 좋은 코드를 관리할 수 있게 된다.

위와 같은 장점들을 누릴 수 있는 좋은 상황이 연출될 것이라고 본다. */

Item* FindItemByItemId(Item items[], int itemCount, int itemId) {
    for (int x = 0; x < itemCount; x++) {
        Item* item = &item[x];
        
        if (item->_itemId == itemId) {
            return item;
        }
    }

    return nullptr;
}

// 아래의 함수를 이제 typedef 를 통해 바꾸어보자.
typedef bool(ITEM_SELECTOR)(Item* item);
bool IsRareItem(Item* item) {
    return item->_rarity >= 2;
}

/* 위에서 바꾼 ITEM_SELECTOR 를 함수에 적용시켜보자. */
Item* FindItem(Item items[], int itemCount, ITEM_SELECTOR* selector) {
    for (int x = 0; x < itemCount; x++) {
        Item* item = &item[x];
        if (selector(item))
            return item;
    }

    return nullptr;
}

int main() {

    // 일반적인 포인터 선언
    int a = 3;
    typedef int DATA;
    DATA* pointer = &a;

    /* 함수를 포인터에 담는다는 개념을 어떻게 이해해야 하는것인가?
    함수로 존재하는 int Add(int a, int b) {}

    포인터를 선언하는데 있어 필요한 데이터타입, 변수명, 포인터 이 3요소가 갖추어져야
    정상적으로 작동하게 된다.

    일반적으로 포인터를 선언하게 될때, 변수명과 포인터는 걱정이 되지 않지만
    함수를 담는 포인터를 만든다고 할때, 이를 어떻게 표현해야하는지가 의문이다.

    일반적인 포인터 -> int* pointer = &value;
    위의 방법처럼 함수를 담는 포인터는 선언할 수가 없기에
    typedef [TYPE] [NAME]; 형태를 사용해야 한다. */

    typedef int(FUNC_TYPE)(int a, int b);
    /* 일반적인 typedef [TYPE] [NAME]; 형태와는 다른 모습으로 선언된다.
    이는 함수의 input / output 값을 명확히 하기위해서 형태가 다른것이다.

    매칭하기 위함 함수 -> int Add(int a, int b) {} 자체를 타입으로 지정하기 위해
    그 형태 자체에 담긴 input / output 형태를 typedef에 작성한다고 보면 된다. */

    using FUNC_TYPE = int(int a, int b); // 모던 C++에서 사용하는 방식

    // 위에서 typedef를 통한 함수의 타입을 지정했다.
    FUNC_TYPE* fn; // 변수명과 포인터를 붙이면 함수를 담을 수 있는 포인터를 선언한 것이다.

    // 이를 어떻게 사용해야 하는가?
    fn = Add;
    /* type이 일치하는 함수를 함수포인터 안에 넣어주면 된다.
    type이 일치해야 한다는 점이 번거로울 수 있으나
    함수를 포인터 형태로 담을 수 있다는 점이 엄청난 이점으로 다가올 것이다. */

    int result = fn(1, 60); // 원래는 Add를 사용하여 인자값을 더했지만 
    // 이제는 Add를 담은 fn으로도 충분히 진행할 수 있다.

    int result2 = (*fn)(1, 40); // 이렇게 사용할 수도 있다.

    /* 굳이 이렇게 함수 포인터를 사용하는 일이 있는가?
    사실은 이를 사용하지 않더라도 명시적으로 사용하는 방법을 택할 수 있다.

    그렇지만 이를 사용하는 이유는 관리하는 측면에서 이점을 가질 수 있다는 것이 크기에 사용하는 것이다. */

    Item items[10] = {};
    items[3]._rarity = 2;
    Item* rareItem = FindItem(items, 10, IsRareItem);
    /* 다양한 동작을 넘겨주고 싶을 때 사용하는 개념으로도 사용할 수 있다는 것이다. 
    
    단점으로는 이에 대한 반환타입과 인자값 타입이 일치해야 한다는 문제가 있다는 것이다.
    */

}