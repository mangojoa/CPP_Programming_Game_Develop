#include <iostream>

using namespace std;

/* [22.07.26] boolean 과 부동소수점 */
bool isPlayer = true;
bool isMonster = false;
/* 사실 bool은 1바이트 정수로 인식한다. */

/* [22.07.26] 부동소수점 = 실수
float double 의 타입이 존재한다.
*/
float buff_Attack = 0.03; // 4바이트
double buff_Healing = 0.2; // 8바이트

/* 부동소수점 = .(소수점)을 유동적으로 움직여서 표현하는 방법
3.141592 = 0.3141592 * 10 = 314.1592 * 10^-2 
위의 식들이 다 같은 의미인 것처럼 자유롭게 실수를 표현하는 것이라 보면된다

하지만 이런식으로 사용하는 것이 아닌... 정규화 작업을 거치게 된다.

1. 정규화 = .(소수점)을 기준으로 유효숫자와 지수를 추출하는 과정
0.3141592 * 10 (사실상 이 형태가 정규화가 진행된 형태이다.)

유효숫자 = 3141592 / 지수 = 1 (10^1 의 지수를 가져온 것)

앞서 말했듯 float과 double의 바이트는 2배 가량 차이가 나는데
float은 간단한 실수의 연산이 필요한 곳에 사용이 된다고 보면 된다.
double은 float의 2배 가량의 용량을 표현하기에 보다 세밀한 연산을 하는데 사용된다.

float = 부호(1) 지수(8) 유효숫자(23) = 32비트 = 4바이트
double = 부호(1) 지수(11) 유효숫자(52) = 64비트 = 8바이트

그럼 본격적으로 실수를 저장해보는 연습을 해보자
1) -3.375를 2진수로 변환
(-)부호는 우선 생략 / 3 + 0.375 로 나눈 후에
3 = 0b11 / 0.375 는 어떻게 2진법으로 나타내는가?

2진법의 경우 수가 커질 수록 2배씩 증가함 -> 수가 작아지면 2배씩 작아짐

.(소수점) 밑으로는 0.5 0.25 0.125 이런식으로 작아짐

0.375 = 0.5 * 0 + 0.25 * 1 + 0.125 * 1 => 0b0.011

0b11 + 0b0.011 = 0b1.1011 이라고 계산이 된다.

이를 정규화 해보자
0b1.1011 * 2^1 로 만들어지는데 그럼 이제 부호 지수 유효숫자를 뽑아내자

1 (부호) 1 (지수) 1011 (유효숫자)
단 지수는 unsigned byte로 보통 표현하기에 (지수)+127을 해줘야한다

결과 : 0b 10000000 1011000.0000.0000.0000.0000 이 된다.
메모리에 저장된 이 값을 추출하면 C058 0000 이라고 나와있다.
이를 계산기의 hex에 입력하면 결과값이 나온다.

프로그래밍에서 부동소수점은 언제나 '근사값'으로 사용되고 있다..
이는 단적인 예시 1/3 = 0.3333... 끊임없는 무한반복소수가 존재하기도 하며
너무 자세한 값을 사용하기에는 공수가 많이 들어가기에 ... '근사값'으로 사용한다.

*/

int main() {
    
    cout << isPlayer << endl;


}