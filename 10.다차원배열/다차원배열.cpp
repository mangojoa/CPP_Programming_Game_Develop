#include <iostream>
using namespace std;

// 다차원 배열

int main() {

    /* 배열을 사용하는 것은 필요에 따라 다양화 될 수 있다.
    하지만 이와 달리 길이가 5인 배열이 n(최소 100개이상)필요하다면 이야기가 달라진다. */


    int first[5] = { 4, 2, 3, 4, 1 };
    int second[5] = { 1, 1, 5, 2, 2 };
    /* 위처럼 하나부터 n개까지의 값을 하나하나 선언했다고 하면 이 또한 메모리 낭비로 이어질 수 있다.
    그렇기에 우리에게 중요한 것은 배열도 구조체처럼 묶어줄 수 있는 개념을 사용하여 메모리 낭비를 최소화 하자는 것이다.*/

    /* 이러한 개념이 바로 '다차원 배열이다.' => 배열을 배열로 가지고 있다 는 개념으로 이해하면 된다. */
    // TYPE 변수이름[x][y] 로 선언하면 된다.
    int apartment2D[2][5] = { {4, 2, 3, 4, 1}, {1, 1, 5, 2, 2} };

    for (int floor = 0; floor < 2; floor++) {
        for (int room = 0; room < 5; room++) {
            int num = apartment2D[floor][room];
            cout << num << " ";
        }
        cout << endl;
    }

    /* 그렇다면 메모리 구조는 어떻게 되었을까? (다차원 배열편)
    일반적인 1차원 배열의 경우, 안에 담긴 데어터를 연이어 보관하고 있다. (각 배열변수에 따라 다른 메모리 공간에 따로 보관한다.)

    다차원 n차원 배열의 경우, 모든 배열을 줄세워서 보관하고 있다.
    즉, 위에서 나온 4 2 3 4 1 / 1 1 5 2 2 를 따로 보관하는 개념이 아니라 
    4 2 3 4 1 1 1 5 2 2 이렇게 연이어 보관하고 있다는 것이다. (다차원 배열의 특징) */

    /* 하지만 2차원 배열은 얼마든지 1차원 배열로 만들 수 있다.
    그렇기에 2차원 배열 구조를 1차원 배열로 합쳐서 만들게 된다면 같은 메모리 구조를 가지게 된다.
    즉, 같은 개념으로 동작할 수 있다는 것이다. */ 
    int apartment1D[10] = {4, 2, 3, 4, 1, 1, 1, 5, 2, 2}; // 1차원 배열
    int apartment2D[2][5] = { {4, 2, 3, 4, 1}, {1, 1, 5, 2, 2} }; // n차원 배열


    /* 2차 배열은 언제 사용할까? 대표적으로 2D 로그라이크 맵을 만들때 사용한다. */
    int map[5][5] = {
        { 1, 0, 1, 1, 1 },
        { 1, 0, 1, 1, 1 },
        { 1, 0, 0, 0, 1 },
        { 1, 0, 1, 0, 1 },
        { 1, 0, 1, 0, 1 }
    };

}
