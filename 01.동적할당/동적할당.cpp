#include <iostream>
using namespace std;

/* 동적 할당 (정말 중요한 개념)

메모리 구조 학습
- 실행할 코드가 저장되는 영역 -> 코드영역
- 전역 / 정적 변수 -> 데이터 영역
- 지역 / 매개 변수 -> 스택 영역

지금까지 데이터 영역 / 스택 영역 을 이용해서 이런 저런 프로그램을 잘 만들어 왔지만 굳이 새로운 영역이 필요할까?
- 동적 할당 -> 힙영역

실제 상황에 대한 부분으로 생각하자
MMORPG 동접이 1명 ~ 6만명 / 몬스터 1마리 ~ 600만마리 가 있다고 가정하자 */

/*
- 스택영역
함수가 끝나면 같이 정리되는 불안정한 메모리 
잠시 함수에 매개 변수를 넘긴다거나 하는 용도로는 적합하다.

- 메모리 영역
프로그램이 실행되는 도중에는 '무조건' 사용되는 메모리

하지만 우리에겐 유동적으로 메모리를 사용하는 구조의 메모리 영역이 필요하다.
그러면서 (스택과는 다르게) 우리가 생성/소멸 시점을 관리할 수 있는 영역의 메모리가 말이다! (그게 바로 힙 영역이다!)

동적할당과 연관된 함수/연산자 : malloc, free, new, delete, new[], delete[] 를 배워보자!

- malloc
할당할 메모리 크기를 건내준다.
메모리 할당 후 시작 주소를 가리키는 포인터를 반환해준다. (메모리 부족 = NULL)

- free
malloc (혹은 기타 calloc, realloc 등) 을 통해 할당된 영역을 해제
힙 관리자가 할당/미할당 여부를 구분해서 관리

- new / delete 
C++에서 추가되는 함수이며 연산자에 해당한다(operator)
new 가 malloc 에 비해 좋긴하다. 하지만 배열과 같이 n개 데이터를 같이 할당하려면 ?

malloc / free vs new / delete 
- 사용성 -> new / delete 가 우위에 있다.
- 타입에 상관없이 특정한 크기의 메모리 영역을 할당 받으려면 ? ->  malloc / free 가 우위에 있다.

하지만 둘의 근본적인 중요한 차이는 따로 존재한다는 것이다.

new / delete는 (생상타입이 클래스일 경우) 생성자/소멸자를 호출해준다!!! => 객체지향과 궁합이 좋은 부분이다.
malloc / free는 (생성타입이 클래스일 경우) 생성자/소멸자를 호출하지 않는다.....=> (하지만 코드적으로 추가는 해줄 수 있다.)

*/

class Monster
{
public:
	int _hp;
	int _x;
	int _y;
};

// Monster monster[500 * 10000]; 
// 이를 실행하면 에러가 발생하진 않으나 문제가 하나 발생한다
// 필요 이상의 메모리를 미리 사용하고 있다는 것이다.
// 메모리를 깔끔하게 사용하지 못하고 있다는 것이다.

int main() {
	// Monster moster[500 * 1000]; // 이를 실행하면 스택오버플로우가 발생한다 .... 

	/*
	유저 영역 [메모장] [lol] [유튜브] -> 우리가 평소에 사용하는 프로그램이 실행되는 영역
	---------------------------------
	커널 영역 (Window 등의 핵심 코드) -> 백그라운드 영역에서 실행되는 프로그램의 영역

	유저 영역(운영체제)에서 제공하는 api 호출 (메모리 내놔!)
	커널 영역에서 메모리 할당해서 건내줌!
	유저 영역에서는 할당된 메모리를 사용한다.


	실질적으로 [                이만큼의 메모리를 미리 할당한다.                     ]
	           [   이 안에서 필요한 만큼을 때어내어 필요할 때 사용한다는 개념이다.   ]

			   C++ 에서는 기본적으로 CRT(C런타임 라이브러리)의 [힙 관리자]를 통해 힙 영역 사용
			   단, 정말 원한다면 우리가 직접 api를 통해 힙을 생성하고 관리할 수도 있음 (MMORPG 서버 메모리 풀링) 
			   
			   이 기능을 malloc(unsignd int x); 함수가 실행을 한다. 
			   
			   잠깐! void* 는 무엇인가?
			   *가 있으니까 포인터는 포인터 (주소가 담긴 바구니) 개념이다.
			   타고가면 void 아무것도 없는가? -> 그것은 아니다.
			   타고가면 void 뭐가 있는지 모르겠으니까 너가 적당히 변환해서 사용해라 라는 개념이다. */
	void* pointer = malloc(1000);

	/* 힙 영역은 어떻게 사용해야 하는가?
	우선적으로 monster를 힙 영역에 만들어보자.

	Monster* m1 = (Monster*)pointer; 를 통해 pointer (힙 영역)의 시작점부터 m1->class 변수를 사용하여 넣어보면 

	&pointer의 시작점에서 부터 m1의 정보가 하나씩 들어가 있음을 알 수 있다. */
	Monster* m1 = (Monster*)pointer;
	m1->_hp = 100;
	m1->_x = 10;
	m1->_y = 1;
	/* void* pointer = malloc(1000); 를 통해서 몬스터를 생성할 영역에 대한 메모리를 생성했음을 알 수 있다. 
	하지만 지금 현재는 이 메모리 영역이 너무 크게 잡혀있어 낭비를 하고 있다는 생각이 들 수 있다. 

	그럴때는 -> void* pointer = malloc(sizeof(Monster)); 를 통해서 Monster의 영역만큼 할당해서 사용할 수도 있다. */

	/* 이제 메모리 영역을 더이상 사용하지 않게 된다면 free(); 를 통해 할당을 해제할 수 있다.

	이로 인해서 정적 할당과 동적 할당의 차이가 발생하는 것이다.
	정적 할당의 경우, 프로그램이 실행됨과 동시에 종료될 때까지 이를 사용하지 않더라도 대기 상태로 가지고 있어야한다.
	(메모리를 낭비하고 있다는 것이다.)

	하지만 동적 할당의 경우, 프로그램의 요청에 따라 사용할 메모리를 배정하고 사용이 끝나면 이를 반환하는 형태를 지니고 있기에
	정적 할당에 비해 메모리를 확실히 관리하는데 있어 엄청난 이점을 가지고 있다는 것이다. */

	/* malloc 과 free 에 관한 에러
	1. heap overflow
	malloc을 통해 할당 받아야하는 메모리보다 적은 메모리를 받게 될 경우,
	바로 크래시가 발생한다. -> 할당 받은 메모리보다 많은 메모리를 사용하기 때문에 문제가 발생

	2. free를 하지 않은 경우,
	정적 할당에 비해 메모리를 관리하는데 이점이 있지만, free를 진행하지 않는다면 정적 할당보다
	좋지 못한 메모리 관리가 된다. 지속적으로 메모리 누수가 일어나게 되면 프로그렘이 종료되기 십상이다.

	3. double free
	free를 진행하고 나서 다시 free를 진행할 경우, 발생하는 크래시로써
	이는 다름아닌 할당받은 부분을 찾지 못하기에 발생하는 에러이다.

	4. ues-after-free
	이 부분이 매우 중요하다.
	만약 malloc / free 를 통해 할당받은 메모리를 반납한 이후에
	할당받은 메모리에서 사용한 부분을 실행하게 된다면 ?
	- 프로그래머 입장 -> 짐싸고 나가야한다.
	- 해커 입장 -> 심봤다!
	이러한 경우가 바로 발견이 된다면 다행이지만 대부분은 바로 발견이 되지 않는다.
	그렇기에 C++에서 가장 중요시 여겨지는 메모리를 조작하는 일을 함에 있어 주의를 해야하는 부분이 강조된다. */

	free(pointer);

	// new / delete 는 한쌍으로 사용해주어야 한다.
	Monster* m2 = new Monster; // malloc 에 비해 어떤 타입의 크기 만큼 자동으로 할당해주는 개념의 new 이다.
	m2->_hp = 100;
	m2->_x = 10;
	m2->_y = 1;

	delete m2; // new 로 생성했다면 delete로 삭제해주어야 한다.

	// malloc에 비해 여러 Monster를 생성하는데 있어 사이즈를 컨트롤하는 부분이 차이가 있다.
	Monster* m3 = new Monster[6]; // 배열 방식으로 선언하여 크기 만큼 Monster를 생성할 수 있다. + new 까지 합쳐지면 이는 완벽하다!

	m3->_hp = 100;
	m3->_x = 10;
	m3->_y = 1;

	delete[] m3; // new Moster[6](new[])로 선언했기에 delete[]로 한 쌍을 이루어야 한다는 것이 특징이다.

}