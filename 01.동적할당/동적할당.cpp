#include <iostream>
using namespace std;

/* 동적 할당 (정말 중요한 개념)

메모리 구조 학습
- 실행할 코드가 저장되는 영역 -> 코드영역
- 전역 / 정적 변수 -> 데이터 영역
- 지역 / 매개 변수 -> 스택 영역

지금까지 데이터 영역 / 스택 영역 을 이용해서 이런 저런 프로그램을 잘 만들어 왔지만 굳이 새로운 영역이 필요할까?
- 동적 할당 -> 힙영역

실제 상황에 대한 부분으로 생각하자
MMORPG 동접이 1명 ~ 6만명 / 몬스터 1마리 ~ 600만마리 가 있다고 가정하자 */

/*
- 스택영역
함수가 끝나면 같이 정리되는 불안정한 메모리 
잠시 함수에 매개 변수를 넘긴다거나 하는 용도로는 적합하다.

- 메모리 영역
프로그램이 실행되는 도중에는 '무조건' 사용되는 메모리

하지만 우리에겐 유동적으로 메모리를 사용하는 구조의 메모리 영역이 필요하다.
그러면서 (스택과는 다르게) 우리가 생성/소멸 시점을 관리할 수 있는 영역의 메모리가 말이다! (그게 바로 힙 영역이다!)

동적할당과 연관된 함수/연산자 : malloc, free, new, delete, new[], delete[] 를 배워보자!

- malloc
할당할 메모리 크기를 건내준다.
메모리 할당 후 시작 주소를 가리키는 포인터를 반환해준다. (메모리 부족 = NULL)

*/

class Monster
{
public:
	int _hp;
	int _x;
	int _y;
};

// Monster monster[500 * 10000]; 
// 이를 실행하면 에러가 발생하진 않으나 문제가 하나 발생한다
// 필요 이상의 메모리를 미리 사용하고 있다는 것이다.
// 메모리를 깔끔하게 사용하지 못하고 있다는 것이다.

int main() {
	// Monster moster[500 * 1000]; // 이를 실행하면 스택오버플로우가 발생한다 .... 

	/*
	유저 영역 [메모장] [lol] [유튜브] -> 우리가 평소에 사용하는 프로그램이 실행되는 영역
	---------------------------------
	커널 영역 (Window 등의 핵심 코드) -> 백그라운드 영역에서 실행되는 프로그램의 영역

	유저 영역(운영체제)에서 제공하는 api 호출 (메모리 내놔!)
	커널 영역에서 메모리 할당해서 건내줌!
	유저 영역에서는 할당된 메모리를 사용한다.


	실질적으로 [                이만큼의 메모리를 미리 할당한다.                     ]
	           [   이 안에서 필요한 만큼을 때어내어 필요할 때 사용한다는 개념이다.   ]

			   C++ 에서는 기본적으로 CRT(C런타임 라이브러리)의 [힙 관리자]를 통해 힙 영역 사용
			   단, 정말 원한다면 우리가 직접 api를 통해 힙을 생성하고 관리할 수도 있음 (MMORPG 서버 메모리 풀링) 
			   
			   이 기능을 malloc(unsignd int x); 함수가 실행을 한다. 
			   
			   잠깐! void* 는 무엇인가?
			   *가 있으니까 포인터는 포인터 (주소가 담긴 바구니) 개념이다.
			   타고가면 void 아무것도 없는가? -> 그것은 아니다.
			   타고가면 void 뭐가 있는지 모르겠으니까 너가 적당히 변환해서 사용해라 라는 개념이다. */
	void* pointer = malloc(1000);

	/* 힙 영역은 어떻게 사용해야 하는가?
	우선적으로 monster를 힙 영역에 만들어보자.

	Monster* m1 = (Monster*)pointer; 를 통해 pointer (힙 영역)의 시작점부터 m1->class 변수를 사용하여 넣어보면 

	&pointer의 시작점에서 부터 m1의 정보가 하나씩 들어가 있음을 알 수 있다. */
	Monster* m1 = (Monster*)pointer;
	m1->_hp = 100;
	m1->_x = 10;
	m1->_y = 1;
	/* void* pointer = malloc(1000); 를 통해서 몬스터를 생성할 영역에 대한 메모리를 생성했음을 알 수 있다. 
	하지만 지금 현재는 이 메모리 영역이 너무 크게 잡혀있어 낭비를 하고 있다는 생각이 들 수 있다. 

	그럴때는 -> void* pointer = malloc(sizeof(Monster)); 를 통해서 Monster의 영역만큼 할당해서 사용할 수도 있다. */

}