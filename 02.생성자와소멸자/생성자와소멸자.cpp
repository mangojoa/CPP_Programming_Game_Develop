#include <iostream>
using namespace std;

/* 생성자와 소멸자
* 클래스에 '소속'된 함수들은 맴버 함수하고 한다.
* 이 중에서 됭장히 특별한 함수 2종이 있는데, 바로 [시작]과 [끝]을 알리는 함수들
* - 시작(탄생) -> 생성자 (여러개 존재 가능)
* - 끝(소멸) -> 소멸자 (오직 1개만)
*/

/* [암시적(inplicit) 생성자]
* 생성자를 명시적으로 만들지 않으면
* 아무 인자도 받지 않는 [기본 생성자]가 컴파일러에 의해 자동으로 만들어짐
* -> 그러나 우리가 명시적으로(Explicit)으로 아무 생성자 하나 만들면, 
* 자동으로 만들어지던 [기본 생성자]는 더이상 만들어지지 않는다.
*/

class Knight {

public:
	// 기본 생성자 (인자가 없는 생성자)
	Knight() {
		cout << "Knight() 기본 생성자 호출" << endl;

		_hp = 100;
		_attack = 10;
		_posY = 0;
		_posX = 0;
	}

	// 소멸자
	~Knight() {
		cout << "~Knight() 소멸자 호출" << endl;
	}

	// 복사 생성자
	Knight(const Knight& knight) { // 자기 자신의 클래스 참조 타입을 인자로 받는다.
		// 어쩔 때 사용하는가?

		// 기존에 생성된 객체(k1)이 있다고 가정하자.
		// 일반적으로 똑같은 데이터릴 지닌 객체가 생성되길 기대하는 생성자라고 생각하면 된다.

		_hp = knight._hp;
		_attack = knight._attack;
		_posY = knight._posY;
		_posX = knight._posX;
	}

	/* 이를 실행하면 프로그램이 실행될 때, 종료될 때 나타나고 있다는 것을 알 수 있다.
	* 이들이 어떤 의미를 가지고 있는가?
	* 
	* 생명주기적으로 생각해보면 생성될때 실행괴면 좋은 로직이 존재할 것이다. 이를 생성자에 넣게 된다면 코드가 간결해지고 파악하기 좋을 것이다.
	* 생성자는 여러개가 존재할 수 있다. 특정조건에 따라 다른 값을 받는 생성자를 사용할 수 있다는 것이다.
	* 
	* 생명주기적으로 소멸자는 마지막에서 한번만 실행되면 된다는 것이 정설이다.
	*/

	// 기타 생성자(타입 변환 생성자)
	explicit Knight(int hp) { // 기타 생성자의 경우, 인자값을 지정해서 사용하는 생성자이다.

		/* 이 중에서 인자를 1개만 받는 기타 생성자를 [타입 변환 생성자]라고 부르기도 한다. 
		C++는 컴파일러가 많은 부분을 커버하고 있기에 장단점으로 진행하고 있다. 그렇기에 이를 자세하게 알아보자. */
		cout << "Knight(int) 생성자 호출" << endl;

		_hp = hp;
		_attack = 10;
		_posY = 0;
		_posX = 0;
	}

	/* 명시적으로 사용하기 위해 작성한 기타 생성자를 암시적으로 사용하지 않기 위해서는 explicit 이라는 코드를 작성해주어야 한다.
	* explicit (명시적) 이라는 의미를 가진 코드이다.
	* 
	* 이를 작성하면 기타생성자를 명시적으로 사용하기 위해서 작성했다는 것을 알림과 동시에 암시적으로 사용하는 로직은 실행하지 않게 해달라는 의미이다.
	* 
	* 이를 통해서 아래의 코드는 오류가 발생한다.
	* HelloKnight(5);
	* 
	* Knight k5;
	* k5 = 1; 과 같은 코드들은 암시적으로 사용되었으나 명시적으로 사용하겠다는 선언을 해버렸기에 더이상 사용할 수 없게 된다.
	* 
	* 그럼에도 불구하고 이를 사용하고 싶다면 명시적으로 코드를 작성해주면 된다.
	* HelloKnight((Knight)5);
	* 
	* Knight k5;
	* k5 = (Knight)1;
	*/

	void Move(int y, int x);
	void Attact();

	void Die() {
		_hp = 0;
		cout << "Die" << endl;
	}
public:
	int _hp;
	int _attack;
	int _posY;
	int _posX;
};

void Knight::Move(int y, int x) {
	_posY = y;
	_posX = x;

	cout << "Move" << endl;
}

void Knight::Attact() {
	cout << "Attact : " << _attack << endl;
}

int main() {
	Knight k1;

	// 복사 생성자를 이용해 k2를 생성해보자
	// k1과 같은 객체를 생성할 것이기에 이렇게 작성한다면 매우 간결하게 같은 객체를 클론할 수 있다는 장점이 돋보인다.
	Knight k2(k1);
	Knight k3 = k1;
	/* 복사 생성자와 관련된 재밌는 이야기 
	위에서는 기본생성자와 복사생성자를 두개 다 만들어서 사용했다. 

	하지만 생성자에는 명시적 생성자와 암시적 생성자 이렇게 두개가 존재하는데
	
	암시적 생성자는 기본생성자 뿐만 아니라 복사생성자까지 생성해준다.
	(이를 알고 싶다면 Knight(const Knight& knight) {} 를 주석으로 처리하고 진행하면 된다.)

	하지만, 기타 생성자는 생성해주지 않는다.
	(이는 인자값이 자기자신을 받지 않는 구조로 되어 있기에 해당하지 않는다.)

	고로, 암시적 생성자는 기본생성자와 복사생성자만 처리해준다는 것을 알 수 있다. */

	// 복사 생성자를 생성할 때 주의해야할 점이 있다. (문법적으로 오류는 아니지만 다른 원리로 진행이 되는 경우)
	Knight k4;
	k4 = k1; 
	/* 위에 작성된 문법은 변수를 선언하고 사용할 때 처럼 해석하면 전혀 문제가 되지 않는 코드이다.
	
	위의 복사생성자 코드와 비교를 해보자.
	
	Knight k2 = k1; <- 이 코드를 어셈블리 언어로 살펴보면
	해당 코드가 실행될 시점에서 복사생성자의 로직으로 이동하는 모습을 볼 수 있다. 
	즉, 기본 생성과 복사 생성이 함께 이루어지고 있다는 것을 알 수 있다.

	Knight k4; <- 이 코드를 어셈블리 언어로 살펴보면
	k4 = k1;
	우선 기본 생성자를 거치고 나서 k4에 k1을 복사하는 형식(복사 생성자)을 거치고 있다는 것을 알 수 있다.
	
	*/

	k1.Move(2, 2);
	k1.Attact();
	k1.Die();

	Knight k5;
	k5 = 1; // 아무리 봐도 k5 라는 객체에 1만 덩그러니 넣게 된다면 에러가 발생하지 않을까 했지만 이와 다르게 발생하지 않고 있다.
	/* 그 이유는 앞서 설면한 [타입 변환 생성자]에 의해서 1이 Knight (int hp) {} 로 이동하는 것을 볼 수 있다.
	
	하지만 앞서 설명했듯 C++에서는 컴파일러가 암시적으로 처리하는 부분이 상당히 많다고 했다. 이는 장점 or 단점으로 작용할 수 있는 큰 요인이 된다. 
	
	아래에 작성된 HelloKnight(5); 를 작성했다. 이는 함수의 인자값과는 전혀 다른 타입의 값이 들어갔음에도 불구하고
	void HelloKnight(Knight k) {} 함수에 위배되지 않는다고 나온다 .... 그 이유는 C++ 컴파일러가 암시적으로 인자값으로 넘겨받은 5라는 값을

	Knight (int hp) {} 에 넘겨서 생성자를 만들고, 이렇게 만들어진 생성자를 void HelloKnight(Knight k) {} 에 넣어 실행하고 있기 때문이다.

	분명 명시적인 용도로 만든 Knight (int hp) {} 기타 생성자가 암시적으로 사용되고 있음을 확인할 수 있는 중요한 부분이다.
	*/
	HelloKnight(5);

}

void HelloKnight(Knight k) {
	cout << "Hello Knight!!" << endl;
}
