#include <iostream>
using namespace std;

class Pet {
    // Knight 클래스가 소유할 동반자 Pet 클래스를 만든다.
public:
    Pet() {
        cout << "Pet()" << endl;
    }
    Pet(const Pet& pet) {
        cout << "Pet(const Pet& pet)" << endl;
    }
    ~Pet() {
        cout << "~Pet()" << endl;
    }
};

class Knight {
public:

public:
    int _hp = 100;
    Pet pet; // Pet 클래스를 만들었으니 이를 기사에게 추가하자.
    /* 하지만 이를 클래스 형태로 Knight 클래스에 추가하게 된다면 
    클래스의 생명주기에 대한 문제가 발생한다.
    
    설계 -> 펫은 플레이어가 죽더라도 소유한 펫은 사라지면 안된다.
    하지만 Knight 클래스가 삭제됨과 동시에 Pet 클래스도 삭제가 된다.
    (설계가 처음부터 이런게 아니라면)

    우선적으로 클래스 안에 클래스를 생성하는 일은 되도록이면
    자제해야 한다. 위의 경우처럼 생명주기가 매우 복잡하게 된다.

    이를 위해서 이때는 Pet* pet; 포인터를 이용한 생성이 올바르다. */
    Pet* pet;
};

int main() {

    Knight knight;
    knight._hp = 200;

    Knight knight2 = knight; // 복사 생성자를 이용해서 생성된다
    // Knight knight2(knight); 위의 코드와 같은 의미를 지닌다.

    Knight knight3; // 기본 생성자를 이용해서 생성
    knight3 = knight; // 복사 대입 연산자를 사용하여 복사를 진행한다.

    /* 컴파일러가 알아서 암시적으로 다 만들어 주니까 편하네 ?! 
    이런 생각을 하면 C++를 너무 쉽게 생각하는 마인드이다.

    위의 코드가 진행되면서 원래의 의도와는 다르게 진행되고 있음을 나는 인지하지 못하고 있었다.
    우선 첫 번째 기사의 _hp 값을 200으로 설정했다.

    여기서 두 번째, 세 번째 코드가 실행될 때, 등장하는 개념이 [얕은 복사]이다.
    
    [ 얕은 복사 Shallow Copy ]
    맴버 데이터를 비트열 단위로 '똑같이' 복사 (메모리 영역 값을 그대로 복사)

    Stack : Knight1 [ hp : 200 / pet : 0x012fc388]
    Stack : Knight2 [ hp : 200 / pet : 0x012fc388]
    Stack : Knight3 [ hp : 200 / pet : 0x012fc388]
    
    분명 나는 Knight1에만 hp = 200; 을 실행했는데, 후에 생성된 Knight에도 같은 값이 들어간 상황을 볼 수 있다.

    왜 이런 상황이 발생하는 것인가? -> 컴파일러가 알아서 '암시적으로' 생성할 때 [얕은 복사]형식으로 복사를 했기 때문이다.
    그럼 복사를 마치고 Knight1 에만 hp = 200; 을 실행하는 방법을 진행하면 되는 것 아닌가?
    -> [얕은 복사]의 개념을 전혀 모를때 할 수 있는 생각이다.

    만약 이를 동적 할당을 받은 상태라고 한다면. 동적 할당을 받은 변수의 주소값을 공유한게 된다.
    즉, [메모리 영역 값을 그대로 들고 온다.] -> 즉, 위의 기사 123 들의 값이 바뀌는 것에 따라 모두의 값이 바뀌는 개념이라고 보면 된다.

    매우 골때리는 상황이 펼쳐진 것이다... */



    
    
}