#include <iostream>
#include <vector>
#include <list>
using namespace std;

/*
vector : 동적배열
[ [1], [2], [3], [4], [5] ]


단일 / 이중 / 원형
list : 연결 리스트

** 단일리스트
[ [1], ------------> [2], ----> [3], --> [4], ------> [5] ]

** 이중리스트
[ [1], <-----------> [2], <---> [3], <-> [4], <-----> [5] ]

** 원형리스트
[ [1], <-----------> [2], <---> [3], <-> [4], <-----> [5], <-> ]

데이터가 나열되어서 저장이 되는 개념은 vector와 동일하다.
하지만 연속된 개념이 적용되지 않는다는 것이다.
(즉, 바로 다음에 데이터가 존재하지 않을 수 있다는 것이다.)

위의 설명처럼 다음 데이터가 존재하는 곳을 Node라고 표현하는데
Node에 대해서 우선 알아보자. */

/* 간단하게 Node를 class화 했다.
이는 우선적으로 _data 안에는 값이 존재한다고 할 때,
_next 에는 *(포인터)형이므로 어떠한 주소값이 들어가는데
이 주소값이 바로 다음 값이 주소값 이라는 것이다.

이렇게 보았을 때, list의 경우 -> Node 들의 집합 이라는 개념이 성립된다. */

class Node {
public:
	Node* _next;
	Node* _prev;
	int		_data;
};

/* 여기서 흥미로운 점이 하나 발생한다.
자기 자신이 생성되기도 전에 자신을 타입으로 생성한다? 
매우 낮설어 할 수 있다.

class Node2 {
public:
	int		_data;
	Node2 _next;
};

이렇게 생성을 한다고 할 때, 컴파일러는 생성이 되지 않는다고 한다. 
왜 ? => 이를 살펴보면 
[ data(4)  next(  data(4)  next( data(4)  next( ........... ) ) ] 

이렇게 무한정으로 계속 생성이 되는 구조로 이어지기 때문에 
컴파일러는 이를 수행할 수 없다고 Error를 발생시킬 것이다.

그럼 왜 class Node는 되는것인가?
왜? => 이를 살펴보면
class Node {
public:
	int		_data;
	Node*	_next;
};

Node*의 포인터 값을 들고 진행하고 있기 때문에 가능한 것이라고 컴파일러는 인식한다.
[ data(4) next(4/8) ] -> 왜 nest() 에 4/8 로 기입되는가? x64 x86 으로 실행하느냐에 따라서
용량이 정해지기 때문에 이는 가능한 이야기라는 것이다. 

-> 이후 Node 안에 무엇이 들어있는지는 추후의 일이고
Node -> Node 가 있다는 개념을 알고만 있자... */


int main() {

	/* list 연결 리스트
	- list의 동작 원리
	- 중간 삽입/삭제
	- 처음/끝 삽입/삭제
	- 임의접근 
	
	1. list의 중간 삽입/삭제에 대하여
	vector와는 달리 list는 각자의 다음/이전의 주소값을 알고 있기 때문에 중간에 삽입/삭제를 진행하더라도

	다음/이전의 주소값이 유효한 값이라면 이는 용이하게 진행된다는 것을 알 수 있다.

	2. list의 처음/끝 삽입/삭제에 대하여
	vector의 경우, 처음 삽입/삭제는 한 칸을 밀어내고 그 칸에 값을 집어 넣는 형식이지만
	list는 주소값을 연결짓는 부분으로 진행되기에 복사의 단계를 거치지 않기 때문에
	vector에 비해 이점을 가진다고 볼 수 있다.

	끝 삽입/삭제의 경우, vector & list는 같은 이점을 가지고 있다.
	하지만 작동 방식이 다르다는 것을 알아두자.

	3. list의 임의접근에 대하여
	vector의 경우, 연속된 데이터의 배열이라는 개념이 성립된 데이터 구조라는 점에서
	vector<int> v1 = [1,2,3,4,5]; 일 때, v1[3]; 과 같이 간단하게 접근할 수 있다. 
	(연속된 배열의 개념이기에)

	하지만 list의 경우는 반대이다.

	list의 경우, indexing 의 개념이 성립되지 않는데
	이유는 연속된 데이터의 배열이라는 개념이 성립되지 않은 데이터 구조라는 점이 이유이다.
	vector 처럼 1 다음의 데이터가 2가 아닐 수도 있다는 경우가 있다는 것이기에
	indexing 방법이 성립되지 않는다. */

	list<int> li;

	// list 기초 사용법!!
	for (int i = 0; i < 100; i++) {
		li.push_back(i); // 데이터를 뒤에 밀어넣는 함수
	}

	// li.push_front(10); // 데이터를 앞에 밀어넣는 함수
	
	int size = li.size();
	// li.capacity(); 는 존재하지 않는다.

	int first = li.front(); // vector = begin() / list = front()
	int last = li.back(); // vector = end() / list = back()

	// li[3] = 10 // 없음

	list<int>::iterator itBegin = li.begin();
	list<int>::iterator itEnd = li.end();

	/* 이제 노드의 개념이 메모리에 어떻게 저장되어 있는지를 확인해보자
	
	ptrBegin = &(li.front()); 를 통해서 li의 첫번째 값의 주소를 확인할 포인터(iterator)를 통해서 접근하자.
	그럼 하나의 주소값을 가지고 있는 메모리를 확인할 수 있는데 이는 어떤 노드를 가리키고 있는지를 표시하도록 만들었다.

	하지만 여기서 한가지 문제가 발생하게 된다.

	처음 타고 들어간 곳의 첫 번째 메모리에는 언제나 container의 값이 존재하기에 구분을 잘 해야한다.
	(그렇지 않는다면 이는 잘못된 메모리 주소로 접근할 수 밖에 없다는 것이다.)

	컨테이너에 해당하는 부분이 어디까지이며 어디부터가 찾고자하는 값인지를 구별해야한다는 것이다.

	무튼 주소를 타고가면 노드를 가리키는 메모리가 담긴 값을 찾을 수 있는데 (그 주소를 A라고 하자)

	A를 타고가면 _next / _prev / _data 값을 확인할 수 있다.

	_next의 값을 타고 넘어가면 다음 노드의 값이 A를 타고 갔을때와 같이 존재하고 있다. 
	
	** 여기서 신기한 점을 하나 발견할 수 있다.
	첫번째 노드의 _prev의 값은 생각하는 것처럼 이전의 값을 나타내는데 
	이 값은 이전의 값을 나타낼 수 있는가 이다. -> 정답은 가능하다. (하지만 진짜 값은 아니다)

	이의 정체는 list의 가상의 노드 _Myhead : end() 값이다.

	즉, end() 의 값은 진짜 노드의 마지막 값을 의미하는 것이 아니라 -> 끝났다는 것을 의미한다.
	그렇기에 _Myhead()는 처음 노드와 끝 노드를 이어주고 있는 하나의 가상 더미 노드라는 것이다. 

	그렇기에 처음 노드의 _prev 나 마지막 노드의 _next 는 _Myhead 를 가리키고 있으며 
	
	[ [1], <-----------> [2], <---> [3], <-> [4], <-----> [5] <-----> _Myhead <-> ] 의 개념이라고 보면 된다. */
	int* ptrBegin = &(li.front());
	int* ptrEnd = &(li.back());

	/* _Myhead : end() 의 존재로 인해 한가지 시험을 해보자
	--itBegin 을 통해서 _Myhead : end() 에 접근할 수 있는가? -> 접근이 안된다.
	--itEnd 을 통해서 _Myhead : end() 에 접근할 수 있는가? -> 접근이 된다.
	++itEnd 을 통해서 첫 번째 노드에 접근할 수 있는가? -> 접근이 안된다.

	처음과 마지막에서는 _Myhead에 접근할 수 없고 오로지 노드를 정상적으로 거쳐야만 가능하다. */

	// list<int>::iterator itTest01 = --itBegin; // 실행시 에러
	list<int>::iterator itTest02 = --itEnd; 
	// list<int>::iterator itTest03 = ++itEnd; // 실행시 에러

	/*------------------------------------------------------------------------------------------*/
	
	/* vector 에서 사용하는 문법들은 list에서 막아둔 것을 알 수 있는데
	이는 연속된 배열의 형태로 존재하는게 아닌 Node의 형태로 이루어져 있기에
	iterator의 이동(메모리이동)이 불가능한 것이다. 
	
	왜 이러한 문법들을 막아둔 것인가??? ->  잘못된 접근을 막기 위해서 처음부터 막아둔 개념이라고 볼 수 있다.
	(vector와 사용하는 방법이 대부분 유사하다고 할 수 있지만 동작원리부터가 아예 다른 기능이기에 착각을 방지하기 위해서) */
	/*list<int>::iterator itTest01 = itBegin + 10; */


	for (list<int>::iterator it = li.begin(); it != li.end(); ++it) {
		cout << *it << endl;
	}

	li.insert(itBegin, 100); // 해당 인덱스 자리에 값을 넣는다.
	
	li.erase(li.begin()); // 위치한 인덱스의 값을 지운다.

	li.pop_front(); // 리스트 제일 앞에 원소 삭제

	li.remove(10); // !!! value와 같은 값을 가지는 element를 모두 제거

	/* 위의 기능안에 있는 함수를 외운다는 것도 중요하지만
	무엇보다 이 기능 (list)가 어떻게 동작하는지 원리를 알고있어야 한다는게 중요하다. */

	/*------------------------------------------------------------------------------------------*/

	/* 임의접근이 느린데 중간 삽입/삭제가 빠를 수 있는가?
	* 50번 인덱스에 있는데이터를 삭제한다! */

	// 하지만 애초에 삭제할 부분의 메모리를 들고 시작한다면 이야기는 다를 수 있다!
	list<int> li01;

	// 삭제할 위치를 기억하는 itRemember
	list<int>::iterator itRemember;

	for (int i = 0; i < 100; i++) {
		if (i == 50) itRemember = li01.insert(li01.end(), i);
		// insert()를 진행하게 되면 insert() 한 위치를 반환해준다는 것을 이용하여 
		// 삭제할 위치를 미리 알고 있는 꼼수를 이용하는 것이다.
		else li01.push_back(i); 
	}

	list<int>::iterator it = li01.begin();
	for (int i = 0; i < 50; i++) ++it;
	// 삭제는 빠르지 삭제할 데이터를 찾는 것은 전혀 빠른게 아니다.

	li01.erase(itRemember);

	return 0;
}